//
//  follower.cpp
//  6thViewImporter
//
//  Created by Dado on 15/10/2015.
//
//

#include <core/math/quaternion.h>
#include "follower.hpp"

#include "hier_geom.hpp"

FollowerPoly::FollowerPoly( const std::vector<Vector3f>& rp1, const std::vector<Vector3f>& rp2,
                            const std::array<size_t, 4>& indices ) {

    auto vsm11 = rp1[indices[0]];
    auto vsm12 = rp2[indices[0]];

    vs[0] = rp1[indices[1]];
    vs[1] = rp2[indices[1]];
    vs[2] = rp1[indices[2]];
    vs[3] = rp2[indices[2]];

    auto vsp11 = rp1[indices[3]];
//    auto vsp12 = rp2[indices[3]];

    auto vnm1 = normalize( crossProduct( vsm11, vs[0], vsm12 ));
    auto vnp1 = normalize( crossProduct( vs[2], vsp11, vs[3] ));

    vn = normalize( crossProduct( vs[0], vs[2], vs[1] ));

    float d1 = dot( vn, vnm1 );
    float d2 = dot( vn, vnp1 );

    Vector3f an1 = d1 > 0.01f ? normalize( vn + vnm1 ) : vn;
    Vector3f an2 = d2 > 0.01f ? normalize( vn + vnp1 ) : vn;
    vncs[0] = an1;
    vncs[2] = an2;
    vncs[1] = vncs[0];
    vncs[3] = vncs[2];
}

const FollowerGap FollowerGap::Empty( 0 );

bool FollowerGap::isGapAt( uint64_t index ) const {
    if ( index >= mGaps.size()) return false;
    return mGaps[index].side != FollowerGapSide::NoGap;
}

bool FollowerGap::isStartGapAt( uint64_t index ) const {
    if ( index >= mGaps.size()) return false;
    return mGaps[index].side == FollowerGapSide::Start;
}

bool FollowerGap::isEndGapAt( uint64_t index ) const {
    if ( index >= mGaps.size()) return false;
    return mGaps[index].side == FollowerGapSide::End;
}

bool FollowerGap::isVisibleAt( uint64_t index ) const {
    ASSERT( index < mGaps.size());
    return mGaps[index].side != FollowerGapSide::NotVisible && mGaps[index].side != FollowerGapSide::Start;
}

void FollowerGap::tagAllNotVisible() {
    for ( int64_t t = 0; t < static_cast<int64_t>( mGaps.size()); t++ ) {
        if ( mGaps[t].side == FollowerGapSide::Start ) {
            for ( int64_t m = 0; m < static_cast<int64_t>( mGaps.size()); m++ ) {
                int64_t index = getCircularArrayIndex( t + m + 1, static_cast<int64_t>( mGaps.size()));
                if ( mGaps[index].side == FollowerGapSide::End ) break;
                mGaps[index].side = FollowerGapSide::NotVisible;
            }
        }
    }
}

bool FollowerGap::isGap( FollowerGapSide side, uint64_t index, float& inset ) const {
    if ( index >= mGaps.size()) return false;
    if ( mGaps[index].side != side ) return false;

    inset = mGaps[index].inset;
    return true;
}

Follower::Follower( subdivisionAccuray subDivs /*= accuracyNone*/,
                    const FollowerFlags& ff /*= FollowerFlags::Defaults*/,
                    const std::string& _name /*= "FollowerUnnamed"*/,
                    const MappingDirection _md /*= MappingDirection::X_POS*/, bool _bUseFlatMapping /*= false */ ) {
    CurrentFlags( ff );
    mSubDivAcc = subDivs;
    mGeomName = _name;
    mGeomType = 0;
    mCapsGeomType = 0;
    mbCapStage = false;
    mbUsePlanarMapping = _bUseFlatMapping;
    mMappingDirection = _md;
}

Vector3f rotateFollowerPlane90( const Vector3f& vpos, const Vector3f& vn3d) {
    Quaternion qp{ vpos, 0.0f };
    float halfAngle = M_PI_2;
    Quaternion r1{ halfAngle, vn3d };
    Quaternion r2{ -halfAngle, vn3d };
    Quaternion vqn = r1 * qp * r2;
    return vqn.vector();
}

void Follower::createLineFromVerts( const std::vector<Vector3f>& _verts, const FollowerGap& gaps ) {
    vcoords.clear();
    vtcoords.clear();
    vplanesb.clear();
    vplanest.clear();

    // Sanitize same points and collinear
    std::vector<Vector3f> verts;
    sanitizePath( _verts, verts, checkBitWiseFlag( mCurrentFlags, FollowerFlags::WrapPath ) );

    int32_t vaCount = static_cast<int32_t>( verts.size());

    Vector3f v1 = Vector3f::ZERO;
    Vector3f v2 = Vector3f::ZERO;

    // This is a pre-loop to assign and tag all the new vertices generated by gaps,
    // we are doing this here so the logic in the triangulator is trivial, otherwise it will be a massive headache to get the logic down in the triangulator.
    std::vector<Vector3f> newverts;
//    uint64_t startGapIndex = 0;
//    uint64_t endGapIndex = 0;
    int newvindex = 0;
    float insetStart = 0.0f;
    float insetEnd = 0.0f;
    for ( int m = 0; m < vaCount; m++ ) {
        bool isGapStart = gaps.isGap( FollowerGapSide::Start, m, insetStart );
        bool isGapEnd = gaps.isGap( FollowerGapSide::End, m, insetEnd );

        bool bWrap = checkBitWiseFlag( mCurrentFlags, FollowerFlags::WrapPath );// && !gaps.isGapAt( m );
        Vector3f vleft = getLeftVectorFromList( verts, m, bWrap );
        Vector3f vright = getRightVectorFromList( verts, m, bWrap );

        Vector3f vpos = verts[m];

        v1 = vleft - vpos;
        v2 = vpos - vright;

        if ( isGapStart ) {
            vpos += ( normalize( v1 ) * insetStart );
            newverts.push_back( vpos );
            mGaps.pushGap( FollowerGapData( FollowerGapSide::Start, insetStart ));
            ++newvindex;
//            startGapIndex = newvindex;
        }
        newverts.push_back( verts[m] );
        mGaps.pushGap( FollowerGapData( FollowerGapSide::NoGap ));
        ++newvindex;
        if ( isGapEnd ) {
            vpos += ( normalize( v2 ) * -insetEnd );
            newverts.push_back( vpos );
            ++newvindex;
//            endGapIndex = newvindex;
            mGaps.pushGap( FollowerGapData( FollowerGapSide::End, insetEnd ));
        }
    }
    // Go around and tag all the points in between start/end gap as "not visible"
    mGaps.tagAllNotVisible();

    // Generated all the verts data, after the gaps calculator
    vaCount = static_cast<int32_t>( newverts.size());
    for ( int m = 0; m < vaCount; m++ ) {
        bool bWrap = ( CurrentFlags() & FollowerFlags::WrapPath );
        Vector3f vleft = getLeftVectorFromList( newverts, m, bWrap );
        Vector3f vright = getRightVectorFromList( newverts, m, bWrap );
        Vector3f vpos = newverts[m];
        Vector3f vn3d = normalize( vright - vpos );
        vnormals3d.push_back( vn3d );

        Vector3f vposPlane;
        Vector3f vposPlaneHandnessCheck;
        Vector3f vposPlanePerpR;
        Vector3f vposPlanePerpL;
        bool bStartEndNonWrapCases = false;
        if ( m == 0 && !bWrap ) {
            vright = getRightVectorFromList( newverts, m + 1, bWrap );
            bStartEndNonWrapCases = true;
        } else if ( m == 0 && bWrap ) {
            auto bs = getRightVectorFromList( newverts, m + 1, bWrap );
            vposPlaneHandnessCheck = normalize(crossProduct(vpos, vright, bs));
        }
        if ( m == vaCount - 1 && !bWrap ) {
            vright = getLeftVectorFromList( newverts, m-1, bWrap );
            bStartEndNonWrapCases = true;
        }
        if ( vaCount == 2 ) {
            vposPlane = mDefaultUpAxis;
        } else {
            vposPlane = normalize(crossProduct(vleft, vpos, vright));
            if ( vposPlane.signScalar() != vposPlaneHandnessCheck.signScalar() ) {
                vposPlane *= -1.0f;
            }
        }
        if ( bStartEndNonWrapCases ) {
            vposPlanePerpL = crossProduct( vpos, vpos + vposPlane, vleft );
            vposPlanePerpR = vposPlanePerpL;
        } else {
            vposPlanePerpL = crossProduct( vleft , vpos, vpos + vposPlane );
            vposPlanePerpR = crossProduct( vpos + vposPlane, vpos, vright );
        }

        Vector3f vn = normalize(vposPlanePerpL + vposPlanePerpR);

        vcoords.push_back( vpos );
        vplanesb.push_back( vn );
        vplanest.push_back( vposPlane );
    }

    if (( CurrentFlags() & FollowerFlags::WrapPath )) {
        vcoords.push_back( vcoords.front());
        vplanesb.push_back( vplanesb.front());
        vplanest.push_back( vplanest.front());
    }
}

void Follower::reserveVBounding( uint64_t size ) {
    // Reserve space for the vBoundingContours
    for ( uint64_t vbi = 0; vbi <= size * 2 - 1; vbi++ ) {
        vboundingContours.push_back( Vector3f::ZERO );
    }
}

void Follower::updateInternalTriangulationVars( std::shared_ptr<GeomData> lGeom, const Vector3f vs[], uint64_t m,
                                                uint64_t t ) {
    // Winding orders vars
    if ( t == 0 && m == 0 ) {
        mStartWindingOrder = mProfile->hasForcedWindingOrder() ? mProfile->windingOrder() : detectWindingOrder( vs[0],
                                                                                                                vs[1],
                                                                                                                vs[2] );
        lGeom->mWindingOrder = mStartWindingOrder;
    }

    // add data to external vboundingContour list IE useful for skirting boards
    if ( m == 0 ) {
        vboundingContours[t] = vs[0];
        vboundingContours[vcoords.size() * 2 - 1 - t] = vs[2];
        if ( t == vcoords.size() - 2 ) {
            vboundingContours[t + 1] = vs[1];
            vboundingContours[vcoords.size() * 2 - 1 - t - 1] = vs[3];
        }
    }
}

void
Follower::createQuadPath( std::vector<Vector2f>& fverts, float width, float height, PivotPointPosition /*alignment*/ ) {
    fverts.clear();
    fverts.push_back( Vector2f( -width * 0.5f, -height * 0.5f ));
    fverts.push_back( Vector2f( -width * 0.5f, height * 0.5f ));
    fverts.push_back( Vector2f( width * 0.5f, height * 0.5f ));
    fverts.push_back( Vector2f( width * 0.5f, -height * 0.5f ));
}

bool Follower::skipGapAt( int t ) {
    return ( mGaps.isStartGapAt( t + 1 ) && mGaps.isVisibleAt( t + 1 ));
}

//void averagePoly( std::vector<FollowerPoly>& polys, uint64_t pi, uint64_t i,
//                  uint64_t i1, uint64_t i2, uint64_t i3 ) {
////    Vector3f vn = polys[pi].vn;
////    polys[pi].vncs[i] = vn;
//
////	float w1 = dot( vn,  polys[i1].vn ) > 0.05f ? 1.0f : 0.0f;
////	polys[pi].vncs[i] += polys[i1].vn * w1;
////
////	w1 = dot( vn, polys[i2].vn ) > 0.05f ? 1.0f : 0.0f;
////	polys[pi].vncs[i] += polys[i2].vn * w1;
////
////	w1 = dot( vn, polys[i3].vn ) > 0.05f ? 1.0f : 0.0f;
////	polys[pi].vncs[i] += polys[i3].vn * w1;
//
////    polys[pi].vncs[i] = normalize( polys[pi].vncs[i] );
//}

void Follower::compositePolys( std::shared_ptr<GeomData> _geom, std::vector<FollowerPoly>& polys,
                               [[maybe_unused]] const CompositeWrapping cpw ) {
    if ( polys.empty()) return;

//    auto numProfilePolys = mProfile->numVerts();
//    int numSegments = static_cast<int>( polys.size() / numProfilePolys );
//    int pi = 0;
//    for ( auto q = 0; q < numSegments; q++ ) {
//        auto pc = q == 0 ? numSegments - 1 : -1;
//        auto nc = q == numSegments - 1 ? ( -( numSegments - 1 )) : 1;
//        pc *= numProfilePolys;
//        nc *= numProfilePolys;
//        for ( auto t = 0; t < numProfilePolys; t++ ) {
//            auto pr = t == 0 ? numProfilePolys - 1 : t - 1;
//            auto nr = t == numProfilePolys - 1 ? 0 : t + 1;
//
//            // left
//            auto bl = pi + pc + pr;
//            auto l = pi + pc;
//            auto tl = pi + pc + nr;
//
//            // center
//            auto tc = pi + nr;
//            auto bc = pi + pr;
//
//            // left
//            auto br = pi + nc + pr;
//            auto r = pi + nc;
//            auto tr = pi + nc + nr;
//
//            // Index 0
//            averagePoly( polys, pi, 0, tc, tl, l );
//            averagePoly( polys, pi, 1, tc, tr, r );
//            averagePoly( polys, pi, 2, l, bl, bc );
//            averagePoly( polys, pi, 3, r, bc, br );
//            ++pi;
//        }
//    }

    for ( auto& fp : polys ) {
        _geom->pushQuadSubDiv( fp.vs, fp.vtcs, fp.vncs );
    }
    polys.clear();
}

void Follower::triangulate( std::shared_ptr<GeomData> _geom ) {
    ASSERT( vcoords.size() > 1 );

    // Temp data for triangulation
    std::vector<Vector3f> rp2;
    std::vector<Vector3f> rp1;
    std::vector<FollowerPoly> polys;

    _geom->resetWrapMapping( mProfile->Lengths());

    reserveVBounding( vcoords.size());

    // Pre-loop setup, allocate/setup first element
    rp1 = mProfile->rotatePoints( vplanesb[0], vplanest[0], vcoords[0] );
    int wrapIndex = rp1.size() > 2 ? 0 : 1;

    size_t t = 0;
    // This triangulate the shape by wrapping points between 2 joints
    for ( ; t < vcoords.size() - 1; t++ ) {

        rp2 = mProfile->rotatePoints( vplanesb[t + 1], vplanest[t + 1], vcoords[t + 1] );

        for ( uint64_t m = 0; m < rp1.size() - wrapIndex; m++ ) {
            int64_t mi =  static_cast<int64_t >(m);
            int64_t rpsizei = static_cast<int64_t >(rp1.size());
            uint64_t mn1 = getCircularArrayIndex( mi - 1, rpsizei );
            uint64_t nextIndex = getCircularArrayIndex( mi + 1, rpsizei );
            uint64_t nextIndexp1 = getCircularArrayIndex( mi + 2, rpsizei );

            FollowerPoly fp{rp1, rp2, { static_cast<size_t>(mn1), static_cast<size_t>(m),
                                         static_cast<size_t>(nextIndex), static_cast<size_t>(nextIndexp1)}};

            bool bAxisExclusionIsFine = true;
            if ( mAxisExtrudeExclusions.size() > 0 ) {
                for ( auto& av : mAxisExtrudeExclusions ) bAxisExclusionIsFine &= dot( av, fp.vn ) < 0.95f;
            }

            //if ( ( bAxisExclusionIsFine && mGaps.isVisibleAt( t ) ) ) lGeom = advanceExtrudeGeom();

            updateInternalTriangulationVars( _geom, fp.vs.data(), m, t );
            if ( UsePlanarMapping()) {
                _geom->planarMapping( absolute( fp.vn ), fp.vs.data(), fp.vtcs.data(), 4 );
            } else {
                _geom->updateWrapMapping( fp.vs.data(), fp.vtcs.data(), m, rp1.size() );
            }

            if ( mGaps.isVisibleAt( t ) && bAxisExclusionIsFine ) {
                polys.push_back( fp );
            }
        }

        if ( skipGapAt( t ) || skipGapAt( t + 1 )) {
            compositePolys( _geom, polys, CompositeWrapping::NoWrap );
            // In case there are gaps we'll cover them as if they were the start/end of the path caps
            if ( skipGapAt( t + 1 ) && ( !( CurrentFlags() & FollowerFlags::NoCaps ))) {
                _geom->addFlatPoly( mProfile->rotatePoints( vplanesb[t+1], vplanest[t+1], vcoords[t + 1] ),
                                                            !mStartWindingOrder );
            }
            if ( skipGapAt( t ) && ( !( CurrentFlags() & FollowerFlags::NoCaps ))) {
                _geom->addFlatPoly( mProfile->rotatePoints(vplanesb[t], vplanest[t], vcoords[t]),mStartWindingOrder );
            }
        }

        // Make previous next array current array
        rp1 = rp2;
    }

    if ( !( CurrentFlags() & FollowerFlags::NoCaps )) {
        compositePolys( _geom, polys, checkBitWiseFlag( mCurrentFlags,
                                                        FollowerFlags::WrapPath ) ? CompositeWrapping::Wrap
                                                                                  : CompositeWrapping::NoWrap );
        mbCapStage = true;
        _geom->addFlatPoly( mProfile->rotatePoints( vplanesb[0], vplanest[0], vcoords[0] ), mStartWindingOrder );

        _geom->addFlatPoly( mProfile->rotatePoints( vplanesb[vcoords.size() - 1], vplanest[vcoords.size() - 1],
                                                    vcoords[vcoords.size() - 1]), !mStartWindingOrder );
        mbCapStage = false;
    }
}

std::shared_ptr<GeomData>
Follower::operator()( std::shared_ptr<PBRMaterial> material,
                      const std::vector<Vector3f>& verts,
                      std::shared_ptr<Profile> profile,
                      const FollowerGap& gaps ) {

    std::shared_ptr<GeomData> geom = std::make_shared<GeomData>(material);

    mProfile = profile;
    Rect2f profilebbox( mProfile->Points() );
    mBBoxProfile.createRect( profilebbox, mProfile->PPP());
    createLineFromVerts( verts, gaps );
    triangulate( geom );

    return geom;
}

std::shared_ptr<HierGeom>
Follower::extrude( [[maybe_unused]] const std::vector<Vector3f>& verts, [[maybe_unused]] std::shared_ptr<Profile> profile, [[maybe_unused]] const FollowerGap& gaps ) {
//    mProfile = profile;
//    Rect2f profilebbox( mProfile->Points());
//    mBBoxProfile.createRect( profilebbox, mProfile->PPP());
//    createLineFromVerts( verts, gaps );
//    // TODO: USE GeomBuilder properly
//    std::shared_ptr<GeomData> geom;
//    triangulate( geom );
//    auto hGeom = std::make_shared<HierGeom>( geom );
//    hGeom->Name( mGeomName );
//    hGeom->GHType( mGeomType );
//    return hGeom;

    ASSERTV(0, "DO NOT USE THIS??");
    return nullptr;
}

std::shared_ptr<HierGeom>
Follower::extrude( const std::vector<Vector2f>& verts, std::shared_ptr<Profile> profile, float _z,
                   const FollowerGap& gaps ) {
    std::vector<Vector3f> vlist;
    for ( auto elem : verts ) {
        vlist.push_back( Vector3f( elem, _z ));
    }
    return extrude( vlist, profile, gaps );
}

std::shared_ptr<HierGeom>
Follower::extrude( const std::initializer_list<Vector3f>& verts, std::shared_ptr<Profile> profile,
                   const FollowerGap& gaps ) {
    std::vector<Vector3f> vlist;
    for ( auto elem : verts ) {
        vlist.push_back( elem );
    }
    return extrude( vlist, profile, gaps );
}

std::shared_ptr<HierGeom>
Follower::pullPillow( [[maybe_unused]] const std::vector<Vector3f>& verts, [[maybe_unused]] float pullHeight,
                      [[maybe_unused]] PillowEdges pe ) {
    ASSERTV( "DEPRECIATED PULL PILLOW", 0 );
    return nullptr;

//	std::vector<Vector3f> raisedVerts;
//	int vsize = static_cast<int>( verts.size() );
//
//	Vector3f normal = normalize( crossProduct( verts[0], verts[1], verts[2] ) );
//	for ( auto& vs : verts ) { raisedVerts.push_back( vs + normal * pullHeight ); }
//
//	FollowerFlags ff = FollowerFlags::Defaults;
//	std::vector<Vector3f> path;
//	int topRightIndex = vsize - 1;
//	int topLeftIndex = 2;
//	switch ( pe ) {
//	case PillowEdges::All:
//	{
//		ff = FollowerFlags::WrapPath;
//		for ( int t = 0; t < vsize; t++ ) path.push_back( JMATH::lerp( 0.5f, verts[t], raisedVerts[t] ) );
//	}
//	break;
//	case PillowEdges::SidesHorizontal:
//	break;
//	case PillowEdges::SidesVertical:
//	break;
//	case PillowEdges::Top:
//	path.push_back( JMATH::lerp( 0.5f, verts[0], raisedVerts[0] ) );
//	path.push_back( JMATH::lerp( 0.5f, verts[1], raisedVerts[1] ) );
//	break;
//	case PillowEdges::TopAndSides:
//	path.push_back( JMATH::lerp( 0.5f, verts[topRightIndex], raisedVerts[topRightIndex] ) );
//	path.push_back( JMATH::lerp( 0.5f, verts[0], raisedVerts[0] ) );
//	path.push_back( JMATH::lerp( 0.5f, verts[1], raisedVerts[1] ) );
//	path.push_back( JMATH::lerp( 0.5f, verts[topLeftIndex], raisedVerts[topLeftIndex] ) );
//	break;
//	case PillowEdges::Bottom:
//	break;
//	case PillowEdges::BottomAndSides:
//	break;
//	case PillowEdges::Left:
//	break;
//	case PillowEdges::Right:
//	break;
//	default:
//	break;
//	}

    // This geometry is composed of 2 pieces at least, so it has to be exploded
//	explodeExtrude();

//	std::shared_ptr<GeomData> lGeom = initGeom();
//
//	lGeom->pull( verts, pullHeight, PullFlags::Tops );
//	mGeom->addChildren( lGeom );
//
//	CurrentFlags( ff );
//	Profile curvedProfile;
//	curvedProfile.createArc( M_PI_2, M_PI, pullHeight*0.5f );
//	curvedProfile.flip( Vector2f::X_AXIS );
//	return extrude( path, curvedProfile );
}

std::vector<Vector2f> Follower::vboundingContours2f() const {
    std::vector<Vector2f> ret;
    for ( auto v : vboundingContours ) {
        ret.push_back( v.xy());
    }
    return ret;
}

void Follower::type( GeomHierType _gt ) {
    mGeomType |= _gt;
    mCapsGeomType |= _gt;
}

void Follower::capsType( GeomHierType _gt ) {
    mCapsGeomType |= _gt;
}

void Follower::excludeAxisFromExtrusion( const Vector3f& _axis ) {
    mAxisExtrudeExclusions.push_back( _axis );
}

std::string Follower::Name() const {
    return mGeomName;
}

void Follower::Name( const std::string& val ) {
    mGeomName = val;
}
